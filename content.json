[{"title":"定时执行周期任务之AlarmManager，了解一下","date":"2018-04-18T04:28:14.000Z","path":"2018/04/18/alarmmanager/","text":"报菜名 ​ AlarmManager可用于计划未来的单次或重复的操作，甚至在应用程序没有运行时也可以执行任务，它通过PendingIntent触发执行各种系统组件，如BroadcastReceiver，Activity或Service等。 ​ 或者说AlarmManager比较适用于应用程序没有运行但仍然需要执行某些操作的场景。如果程序运行时需要执行简单的定时操作，使用Handler的postAtTime()和postDelay()就可以了。 在设备重启后，提醒自动失效，需要手动计划之前注册的提醒 注意事项唤醒类型 ELAPSED_REALTIME ELAPSED_REALTIME_WAKEUP RTC RTC_WAKEUP 根据设备上次启动以来的时间值（毫秒）触发提醒 根据经过的时间触发提醒，如果设备处于休眠状态，将被激活 根据UTC时间触发警告 根据UTC时间触发警告，如果设备处于休眠状态，将被激活 注意，如果使用ELAPSED_REALTIME_WAKEUP或RTC_WAKEUP这种唤醒类型的提醒，系统虽然会被唤醒但是不会保持唤醒状态，在执行唤醒事件的后台工作时，需要通过PowerManager获得WakeLock，否则系统会重新将设备转入休眠状态，你要本要执行的操作也会被停止。 ###PendingIntent PendingIntent有很多构造方法，但是必须要保证它能正确的指向要触发的应用程序组件。 pendingintent.png 上菜AlarmReceiver12345678910111213141516171819public class AlarmReceiver extends BroadcastReceiver &#123; private IntentFilter mIntentFilter; public static final String ACTION_ALARM = \"ACTION_ALARM\"; public AlarmReceiver() &#123; mIntentFilter = new IntentFilter(); mIntentFilter.addAction(ACTION_ALARM); &#125; @Override public void onReceive(Context context, Intent intent) &#123; if (mIntentFilter.matchAction(intent.getAction())) &#123; Calendar now = Calendar.getInstance(); Toast.makeText(context, \"Msg：\" + SimpleDateFormat.getTimeInstance().format(now.getTime()), Toast.LENGTH_SHORT).show(); &#125; &#125;&#125; 注意注册：1&lt;receiver android:name=\".AlarmReceiver\"/&gt; AlarmActivity 1234567891011121314151617181920212223242526272829public class AlarmActivity extends AppCompatActivity &#123; private AlarmManager mAlarmManager; private PendingIntent mPendingIntent; private Intent mIntent; private long mInterval = 5000; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_alarm); mAlarmManager = (AlarmManager) getSystemService(Context.ALARM_SERVICE); mIntent = new Intent(this,AlarmReceiver.class); mIntent.setAction(AlarmReceiver.ACTION_ALARM); mPendingIntent = PendingIntent.getBroadcast(this, 0, mIntent, 0); &#125; public void start(View view) &#123; mAlarmManager.setRepeating( AlarmManager.ELAPSED_REALTIME, SystemClock.elapsedRealtime() + mInterval, mInterval, mPendingIntent); &#125; public void cancle(View view) &#123; mAlarmManager.cancel(mPendingIntent); &#125;&#125; 示例2 每天上午9点执行任务12345678910111213141516171819202122232425public void start2(View view) &#123; long oneDay=24*3600*100; long firstTime; //创建一个日历，并设置提醒的时间为09:00 Calendar startTime = Calendar.getInstance(); startTime.set(Calendar.HOUR_OF_DAY,9); startTime.set(Calendar.MINUTE,0); startTime.set(Calendar.SECOND,0); Calendar now=Calendar.getInstance(); if (now.before(startTime))&#123; //现在还没到上午9点，从今天算起 firstTime=startTime.getTimeInMillis(); &#125;else&#123; //从明天上午9点算起 startTime.add(Calendar.DATE,1); firstTime=startTime.getTimeInMillis(); &#125; //设置提醒 mAlarmManager.setRepeating( AlarmManager.RTC_WAKEUP, firstTime, oneDay, mPendingIntent); &#125; 最后​ 十九岁那年的分水岭，Android4.4（19）开始所有的提醒都是不准确的，这意味着讲通过一个小窗口触发它们，连同这个新行为还一起添加了API方法setExat(),通过这个方法我们可以声明下面的提醒不能放入不准确的窗口。 ​","tags":[{"name":"android","slug":"android","permalink":"http://tsdking.github.io/tags/android/"}]},{"title":"定时执行周期任务之JobScheduler,了解一下","date":"2018-04-17T09:34:59.000Z","path":"2018/04/17/jobscheduler/","text":"JobScheduler是Android5.0及以后的版本由系统提供的用于解决高效处理计划后台工作的系统服务即使应用程序进程当前未运行,计划的任务也会运行,框架自动处理为计划作业获得唤醒锁的工作,从而甚至在设备空闲时,工作也会继续进行. 应用场景- 后台周期性任务 - 非及时性工作如定期数据库数据更新 - 设备充电时需要执行的工作,一般是不需要经常执行但是比较耗时耗电的操作如上传一些资源,网络拉取一些统计数据之类的 - 设备空闲时(未激活,休眠时)需要执行的工作 - 特定网络状态时才需要执行的工作 适用版本1Android 5.0以上即SDK&gt;=21 优点1. 避免频繁的唤醒硬件模块，造成不必要的电量消耗 2. 避免在不合适的时间(例如低电量情况下、弱网络或者移动网络情况下的)执行过多的任务消耗电量 3. Android Framework层会尝试尽可能的**成批执行**操作,从而最大限度减少对设备电池和网络使用率的影响 缺点非严格的计时,即计时的默认操作可能是不准确的 看代码WorkJobService123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@TargetApi(Build.VERSION_CODES.LOLLIPOP)public class WorkJobService extends JobService &#123; private static final int MSG_JOB = 1; private Handler mJobProcessor = new Handler(new Handler.Callback() &#123; @Override public boolean handleMessage(Message msg) &#123; if(msg.what==MSG_JOB)&#123; JobParameters params = (JobParameters) msg.obj; /** * 完成异步工作之后 必须触发jobFinished以使下一个计划任务运行 */ doSomething(); jobFinished(params, false); &#125; return true; &#125; &#125;); private void doSomething() &#123; Toast.makeText(this, \"time:\" + System.currentTimeMillis(), Toast.LENGTH_SHORT).show(); &#125; @Override public boolean onStartJob(JobParameters params) &#123; mJobProcessor.sendMessageDelayed( Message.obtain(mJobProcessor, MSG_JOB, params), 5000); /** * 1.如果此处异步完成作业,false; * 2.如果需要执行更多后台工作,true; * 对于第二种情况必须调用jobFinished()以通知系统作业完成 */ return true; &#125; @Override public boolean onStopJob(JobParameters params) &#123; //停止作业时,必须取消挂起的作业 mJobProcessor.removeMessages(MSG_JOB); /** * true计划作业 * false删除作业 */ return false; &#125;&#125; 注意:不要忘记在清单文件中注册,JobService本身继承Service,和普通的service区别是需要加上这个权限 android:permission=&quot;android.permission.BIND_JOB_SERVICE&quot;,否则在执行计划任务时会产生异常,我们需要将此服务暴露给framework,因此Android要求通过BIND_JOB_SERVICE权限保护该服务,只有framework可以拥有该权限,它保护我们的服务不被其他应用程序访问,123456789101112 &lt;application android:allowBackup=\"true\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:supportsRtl=\"true\" android:testOnly=\"false\" android:theme=\"@style/AppTheme\"&gt; ...... &lt;service android:name=\".WorkJobService\" android:permission=\"android.permission.BIND_JOB_SERVICE\"/&gt; ......&lt;/application&gt; JobSchedulerActivity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class JobSchedulerActivity extends AppCompatActivity &#123; JobScheduler jobScheduler; int interval = 5000; public static final int JOB_ID = 1; private JobInfo mJobInfo; @TargetApi(Build.VERSION_CODES.LOLLIPOP) @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_job_scheduler); jobScheduler = (JobScheduler) getSystemService(Context.JOB_SCHEDULER_SERVICE); mJobInfo = new JobInfo.Builder( JOB_ID, new ComponentName(getPackageName(), WorkJobService.class.getName()) ) /** * 表示应在给定时间间隔内定期运行作业,直到其被明确取消 */ .setPeriodic(interval) /** * 描述作业运行必备的网络条件 * NETWORK_TYPE_NONE = 0 默认值,表示作业不需要网络访问 * NETWORK_TYPE_ANY = 1 需要网络连接 * NETWORK_TYPE_UNMETERED = 2 必须是wifi网络状态,否则不会触发作业 */ .setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY) /** * 作业运行,必须时在设备充电状态 * 适合较少执行,但是比较耗电的任务 */ .setRequiresCharging(true) /** * 作业运行,必须时在设备未激活或睡眠状态 * 适合较少执行,但是比较耗电的任务 */ .setRequiresDeviceIdle(true) /** * 设置设备重启时,如何启动计划作业 * true 由framework自动启动计划作业 * false 由应用手动启动计划作业(默认) */ .setPersisted(false) /** * 设置对于失败的作业如何何时重新计划使其再次运行 * 如:在资源(网络访问等)临时不可用时尽可能减少不必要的重试次数 */ .setBackoffCriteria(DEFAULT_INITIAL_BACKOFF_MILLIS, BACKOFF_POLICY_EXPONENTIAL) .build(); &#125; @TargetApi(Build.VERSION_CODES.LOLLIPOP) public void start(View view) &#123; /** * 多次执行同一个任务返回同一个任务id,不会重复执行任务 */ int result = jobScheduler.schedule(mJobInfo); if (result &lt;= 0) &#123; Toast.makeText(this, \"失败\", Toast.LENGTH_SHORT).show(); &#125;else&#123; Toast.makeText(this, \"成功\", Toast.LENGTH_SHORT).show(); &#125; &#125; @TargetApi(Build.VERSION_CODES.LOLLIPOP) public void stop(View view) &#123; /** * 任务id必须匹配传递给JobInfo的id,需要保存该id */ jobScheduler.cancel(JOB_ID); &#125;&#125;","tags":[{"name":"android","slug":"android","permalink":"http://tsdking.github.io/tags/android/"}]},{"title":"最快最简单的排序算法","date":"2018-04-16T15:31:58.000Z","path":"2018/04/16/sort-algorithm-1/","text":"桶排序的基本思想是将一个数据表分割成许多buckets，然后每个bucket各自排序，或用不同的排序算法，或者递归的使用bucket sort算法。也是典型的divide-and-conquer分而治之的策略。它是一个分布式的排序，介于MSD基数排序和LSD基数排序之间。 基本流程 建立一堆buckets； 遍历原始数组，并将数据放入到各自的buckets当中； 对非空的buckets进行排序； 按照顺序遍历这些buckets并放回到原始数组中即可构成排序后的数组。 12345678910111213141516171819202122232425262728293031public static void main(String[] args) &#123; /** * 定义一个length=11的int数组book用来记录 * 并舒适化默认值都为0 */ int[] book=new int[11]; int length1 = book.length; for (int i = 0; i &lt; 11; i++) &#123; book[i]=0; &#125; /** * 定义一个任意length的数组source，但是保证数组中每个元素在[0,10]内 */ int[] source=&#123;0,8,3,3,5,2,9&#125;; int length = source.length; for (int i = 0; i &lt; length; i++) &#123; /** * source中的元素每出现一次 * book中对应下标的值就加1 */ book[source[i]]++; &#125; for (int i = 10; i &gt;= 0; i--) &#123; /** * 序号出现几次就打印几次 */ for (int j = 1; j &lt;=book[i] ; j++) &#123; System.out.print(i+\" \"); &#125; &#125; &#125; 简单解释上述代码是桶排序算法简单的java实现，形象地描述就是如果我们要对0~10之间的数字排序，那么我们就准备11个桶（0~10共11个数），每出现一个数，就在对应编号的桶中放一个小旗子，最后只要数一数每个桶中有几个小旗子就行了。 优点每个桶的作用实际就是标记每个数出现的次数。该算法的时间复杂度是O（m+n+m+n）即O（2*（m+n）），忽略较小的常数，最终桶排序的时间复杂度为O（M+N），这是一个很快的排序算法（时间复杂度通常用大写字母表示）； 缺点特费空间，这是典型的空间换时间，还有如果要对一些小数排序，怎么办？","tags":[{"name":"算法","slug":"算法","permalink":"http://tsdking.github.io/tags/算法/"}]},{"title":"Hexo博客搭建笔记","date":"2018-04-14T08:34:09.740Z","path":"2018/04/14/hexo-blog-note/","text":"一、安装基础环境 Node.js Git具体安装过程自行搜索，通过以下两条命令验证是否安装成功，否则不能执行第二步；12node --versiongit --version 二、安装hexoHexo官网 1npm install hexo-cli -g 三、初始化项目 使用如下命令初始化项目1hexo init blog 命令中blog可随意命名，有意义即可，相当于项目的根目录，以后所有的操作都在该目录下，该命令在哪执行就在哪创建项目；当然，也可以先创建项目文件夹，cd到项目文件夹后再执行init命令。命令执行后，框架会自动下载相关资源，并完成初始化该过程的长短取决于你的网速 生成各目录的作用 node_modules：各种依赖包 public：存放生成的静态页面 scaffolds：命令生成文章等的模板 source：用命令创建的各种文章md文件 themes：存放各种主题 _config.yml：整个博客的配置 db.json：source解析所得到的 package.json：项目所需模块项目的配置信息 2.进入项目目录,安装框架依赖的模块 1npm install 该命令会安装 ./node_modules目录下的安装包 至此，整个项目初始化完成，可以执行以下命令欣赏一下了 1hexo server 该命令主要用来启动本地服务器，预览项目 四、安装主题（可选）这里简单推荐几个： hexo-theme-indigo hexo-theme-next hexo-theme-yilia hexo-theme-material hexo-theme-icarus 具体配置请查看各主题wiki文档，可能会用到的几个命令 123hexo cleanhexo ghexo server 五,发布到GitHub Pages 以.github.io为名创建一个新仓库，具体操作看官方文档 简单配置一下_config.yml文件12345deploy: type: git repo: git@github.com:tsdking/tsdking.github.io.git branch: master message: &apos;站点更新:&#123;&#123;now(&quot;YYYY-MM-DD HH/mm/ss&quot;)&#125;&#125;&apos; 注意repo换成自己上一步新建仓库的地址 六、发布1hexo d -g 注意：需要先安装hexo-deployer-git1npm install hexo-deployer-get --save","tags":[]},{"title":"Hello World","date":"2017-11-28T07:02:25.505Z","path":"2017/11/28/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]