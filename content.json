[{"title":"如何把项目从SVN迁移到GIT,同时保留提交记录等信息","date":"2018-06-13T07:59:15.000Z","path":"2018/06/13/project-svn-to-git/","text":"由于项目发展规划需求,需要把原来在svn上的代码迁移到gitlab仓库,同时需要保留原提交记录等关键信息,由于这样的需求并不常见,所以记录一下具体的操作流程,以免以后遇到再做重复工作; 1.创建一个文件夹如gitRepo,进入该文件执行如下命令12git svn clone --stdlayout &#123;your project's svn url&#125;#如:git svn clone --stdlayout svn://svnserver/prodemo 上述命令执行后,可能需要认证即需要输入用户名及密码,此时按照提示操作即可,此外该命令执行比较慢,因为它是从项目第一个版本的第一条记录开始clone,并有大量log输出,没意义等待执行完毕即可,这个过程可以去喝杯茶; 2.进入clone下来的项目目录即有.git文件夹的那个,执行如下命令 1git remote -v 查看远程仓库,如果有的话先删掉它,因为要重新设置远程仓库地址,以免有干扰 1git remote rm origin 3.添加git远程仓库地址1git remote add origin git@x.x.x.x/project-name.git 4.推送到远程仓库123456git add .git commitgit push -u origin master#或者git push -u origin --allgit push -u origin --tags 5.Congratulations,完成了! 6.补充一点拉取远程仓库全部分支,并创建本地对应分支 git命令查看所有远程分支1git branch -r 拉取远程分支并创建本地分支12git checkout -b branchName origin/branchName#如 git checkout -b dev origin/dev 或者1git fetch origin branchName:branchName 两者的区别就是第二种fetch不会自动切换到对应的分支,需要手动执行 git checkout branchName 参考链接: 1.SVN项目迁移到Git上(并带有完整的提交记录) 2.从SVN迁移代码到Git实践总结","tags":[{"name":"android","slug":"android","permalink":"http://tsdking.github.io/tags/android/"}]},{"title":"Android安全防护","date":"2018-06-05T02:07:49.000Z","path":"2018/06/05/android-safety-protection/","text":"重打包校验签名,签名的hashCode是唯一值 123456789101112131415public static int getSignature(String packageName) &#123; PackageManager packageManager = this.getPackageManager(); PackageInfo info = null; int sig = 0; try &#123; info = packageManager.getPackageInfo(packageName, PackageManager.GET_SIGNATURES); Signature[] signatures = info.signatures; sig = signatures[0].hashCode(); &#125; catch (Exception e) &#123; sig = 0; e.printStackTrace(); &#125; return sig; &#125; 模拟器监测设备是否是模拟器 检测模拟器上的几个特殊文件 检测模拟器上的特殊号码 检测设备IDS是不是“000000000000000” 检测是否还有传感器、蓝牙 检测手机上才有的硬件信息 检测手机的运营商 1234567891011121314151617/** * 检查IDS * * @param context * @return */ public static boolean chechDeviceIDS(Context context) &#123; @SuppressLint(\"ServiceCast\") TelephonyManager telecomManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE); @SuppressLint(\"MissingPermission\") String deviceId = telecomManager.getDeviceId(); if (deviceId.equalsIgnoreCase(DEVICE_ID)) &#123; Log.e(TAG, \"chechDeviceIDS==\" + DEVICE_ID); return true; &#125; return false; &#125; 1234567891011121314151617/** * 检查模拟器特有的文件 * * @param context * @return */ public static boolean chechDeviceFile(Context context) &#123; for (int i = 0; i &lt; DEVICE_FILE.length; i++) &#123; String file_name = DEVICE_FILE[i]; File qemu_file = new File(file_name); if (qemu_file.exists()) &#123; Log.e(TAG, \"chechDeviceFile==\" + true); return true; &#125; &#125; return false; &#125; 12345678910111213141516171819/** * 检查特有电话号码 * * @param context * @return */ public static boolean chechDevicePhone(Context context) &#123; @SuppressLint(\"ServiceCast\") TelephonyManager telecomManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE); @SuppressLint(\"MissingPermission\") String phoneNumber = telecomManager.getLine1Number(); for (String phone : DEVICE_PHONE) &#123; if (phone.equalsIgnoreCase(phoneNumber)) &#123; Log.e(TAG, \"chechDevicePhone==\" + phoneNumber); return true; &#125; &#125; return false; &#125; 1234567891011121314151617181920212223/** * 检查特是否含有设备 * * @param context * @return */ public static boolean chechDeviceBuild(Context context) &#123; String board = Build.BOARD; String bootloader = Build.BOOTLOADER; String brand = Build.BRAND; String device = Build.DEVICE; String hardware = Build.HARDWARE; String model = Build.MODEL; String product = Build.PRODUCT; if (board.equalsIgnoreCase(\"unknown\") || bootloader.equalsIgnoreCase(\"unknown\") || brand.equalsIgnoreCase(\"generic\") || model.equalsIgnoreCase(\"sdk\") || product.equalsIgnoreCase(\"goldfish\")) &#123; Log.e(TAG, \"chechDeviceBuild==\" + \"find emulatorBuild\"); return true; &#125; return false; &#125; 反编译Proguard混淆 Proguard 是一个混淆代码的开源项目，Proguard主要的作用是混淆，当然他还有着对字节码进行缩减体积、优化等功能，我主要关注的是混淆 基本语法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950-include &#123;filename&#125; #从给定的文件中读取配置参数 -basedirectory &#123;directoryname&#125; #指定基础目录为以后相对的档案名称 -injars &#123;class_path&#125; #指定要处理的应用程序jar,war,ear和目录 -outjars &#123;class_path&#125; #指定处理完后要输出的jar,war,ear和目录的名称 -libraryjars &#123;classpath&#125; #指定要处理的应用程序jar,war,ear和目录所需要的程序库文件 -dontskipnonpubliclibraryclasses #指定不去忽略非公共的库类。 -dontskipnonpubliclibraryclassmembers #指定不去忽略包可见的库类的成员。 #保留选项 -keep &#123;Modifier&#125; &#123;class_specification&#125; #保护指定的类文件和类的成员 -keepclassmembers &#123;modifier&#125; &#123;class_specification&#125; #保护指定类的成员，如果此类受到保护他们会保护的更好 -keepclasseswithmembers &#123;class_specification&#125; #保护指定的类和类的成员，但条件是所有指定的类和类成员是要存在。 -keepnames &#123;class_specification&#125; #保护指定的类和类的成员的名称（如果他们不会压缩步骤中删除） -keepclassmembernames &#123;class_specification&#125; #保护指定的类的成员的名称（如果他们不会压缩步骤中删除） -keepclasseswithmembernames &#123;class_specification&#125; #保护指定的类和类的成员的名称，如果所有指定的类成员出席（在压缩步骤之后） -printseeds &#123;filename&#125; #列出类和类的成员-keep选项的清单，标准输出到给定的文件 #压缩 -dontshrink #不压缩输入的类文件 -printusage &#123;filename&#125; -whyareyoukeeping &#123;class_specification&#125; #优化 -dontoptimize #不优化输入的类文件 -assumenosideeffects &#123;class_specification&#125; #优化时假设指定的方法，没有任何副作用 -allowaccessmodification #优化时允许访问并修改有修饰符的类和类的成员 #混淆 -dontobfuscate #不混淆输入的类文件 -printmapping &#123;filename&#125; -applymapping &#123;filename&#125; #重用映射增加混淆 -obfuscationdictionary &#123;filename&#125; #使用给定文件中的关键字作为要混淆方法的名称 #指定外部模糊字典-obfuscationdictionary dictionary.txt#指定class模糊字典#-classobfuscationdictionary filename#指定package模糊字典#-packageobfuscationdictionary filename-overloadaggressively #混淆时应用侵入式重载 -useuniqueclassmembernames #确定统一的混淆类的成员名称来增加混淆 -flattenpackagehierarchy &#123;package_name&#125; #重新包装所有重命名的包并放在给定的单一包中 -repackageclass &#123;package_name&#125; # 重新包装所有重命名的类文件中放在给定的单一包中 -dontusemixedcaseclassnames #混淆时不会产生形形色色的类名 -keepattributes &#123;attribute_name,...&#125; #保护给定的可选属性，例如LineNumberTable, LocalVariableTable, SourceFile, Deprecated, Synthetic, Signature, and #InnerClasses. -renamesourcefileattribute &#123;string&#125; #设置源文件中给定的字符串常量 实际代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859-ignorewarnings # 忽略警告，避免打包时某些警告出现 -optimizationpasses 5 # 指定代码的压缩级别 -dontusemixedcaseclassnames # 是否使用大小写混合 -dontskipnonpubliclibraryclasses # 是否混淆第三方jar -dontpreverify # 混淆时是否做预校验 -verbose # 混淆时是否记录日志 -optimizations !code/simplification/arithmetic,!field/*,!class/merging/* # 混淆时所采用的算法 -libraryjars libs/treecore.jar -dontwarn android.support.v4.** #缺省proguard 会检查每一个引用是否正确，但是第三方库里面往往有些不会用到的类，没有正确引用。如果不配置的话，系统就会报错。 -dontwarn android.os.** -keep class android.support.v4.** &#123; *; &#125; # 保持哪些类不被混淆 -keep class com.baidu.** &#123; *; &#125; -keep class vi.com.gdi.bgl.android.**&#123;*;&#125; -keep class android.os.**&#123;*;&#125; -keep interface android.support.v4.app.** &#123; *; &#125; -keep public class * extends android.support.v4.** -keep public class * extends android.app.Fragment -keep public class * extends android.app.Activity -keep public class * extends android.app.Application -keep public class * extends android.app.Service -keep public class * extends android.content.BroadcastReceiver -keep public class * extends android.content.ContentProvider -keep public class * extends android.support.v4.widget -keep public class * extends com.sqlcrypt.database -keep public class * extends com.sqlcrypt.database.sqlite -keep public class * extends com.treecore.** -keep public class * extends de.greenrobot.dao.** -keepclasseswithmembernames class * &#123; # 保持 native 方法不被混淆 native &lt;methods&gt;; &#125; -keepclasseswithmembers class * &#123; # 保持自定义控件类不被混淆 public &lt;init&gt;(android.content.Context, android.util.AttributeSet); &#125; -keepclasseswithmembers class * &#123; # 保持自定义控件类不被混淆 public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int); &#125; -keepclassmembers class * extends android.app.Activity &#123; //保持类成员 public void *(android.view.View); &#125; -keepclassmembers enum * &#123; # 保持枚举 enum 类不被混淆 public static **[] values(); public static ** valueOf(java.lang.String); &#125; -keep class * implements android.os.Parcelable &#123; # 保持 Parcelable 不被混淆 public static final android.os.Parcelable$Creator *; &#125; -keep class MyClass; # 保持自己定义的类不被混淆 注意不能混淆的情况 四大组件由于在Mainfest中注册了，所以不能被混淆 jin调用的Java的接口方法 系统接口方法 R文件的混淆可能会导致引用错误（如果有地方使用反射机制，R文件被混淆之后就会找不到资源） 第三方库指定不能混淆的类 加固略","tags":[{"name":"android","slug":"android","permalink":"http://tsdking.github.io/tags/android/"}]},{"title":"RPM，Yum，systemd学习笔记","date":"2018-06-02T14:02:52.000Z","path":"2018/06/02/linux-redhat-package-manager/","text":"红帽软件包管理器RPM，类似windows的控制面板，会建立统一的数据库文件，详细记录软件信息并能够自动分析依赖关系，但并不能解决依赖冲突等问题； 常用的RPM命令 作用 命令 安装软件 rpm -ivh filename.rpm 升级软件 rpm -Uvh filename.rpm 卸载软件 rpm -e filename.rpm 查询软件描述信息 rpm -qpi filename.rpm 列出软件文件信息 rpm -qpl filename.rpm 查询文件属于哪个PRM rpm -qf filename Yum可以根据用户的需求分析出所需软件包及其相关依赖的关系，并自动从服务器下载安装到系统中； 常用的Yum命令 作用 命令 列出所有仓库 yum repolist all 列出仓库中所有软件包 yum list all 查看软件包信息 yum info 软件包名称 安装软件包 yum install 软件包名称 重新安装软件包 yum reinstall 软件包名称 升级软件包 yum update 软件包名称 移除软件包 yum remove 软件包名称 清除所有仓库缓存 yum clean all 检查可更新的软件包 yum check-update 查看系统中已安装的软件包组 yum grouplist 安装指定 的软件包组 yum groupinstall 软件包组 移除指定的软件包组 yum groupremove 软件包组 查询指定的软件包组信息 yum groupinfo 软件包组 systemd初始化进程 Linux开机过程：BIOS-&gt;Boot Loader-&gt;加载系统内核-&gt;内核初始化-&gt;最后启动初始化进程systemd;systemd作为linux系统的第一个进程，同时接管了syslogd，udev，cgroup的服务的工作，需要完成系统中初始化相关的工作 如果想要将系统默认的运行目标修改为“多用户，无图形”，可以使用如下命令1ln -sh /lib/systemd/system/multi-user.target /etc/systemd/system/default.target 即用ln命令把多用户模式目标文件连接到 /etc/systemd/system目录 作用 命令 启动服务 systemctl start foo.service 重启服务 systemctl restart foo.service 停止服务 systemctl stop foo.service 重新加载配置文件（不终止服务） systemctl reload foo.service 查看服务状态 systemctl status foo.service 开机自动启动 systemctl enable foo.service 开机不自启动 systemctl disable foo.service 查看指定服务是否为开机启动 systemctl is-enabled foo.service 查看各个级别下服务的启动禁用情况 systemctl list-unit-files –type=service","tags":[{"name":"linux","slug":"linux","permalink":"http://tsdking.github.io/tags/linux/"}]},{"title":"IDEA-Unmapped Spring configuration files found解决办法","date":"2018-06-02T07:27:42.000Z","path":"2018/06/02/IDEA-Unmapped/","text":"问题描述打开IDEA，提示这样一个警告： 12警告标题：“Spring Configuration Check”警告内容：“Unmapped Spring configuration files found.Disable…Please Configure/setup Spring facet for modules:…” 解决办法【File】-&gt;【Project Structure…】-&gt;【Facets】-&gt;【点击】“+” -&gt;【选择】Spring-&gt;【点击】module-&gt;【点击】OK按钮 -&gt;【点击】“+” -&gt;【选择】配置文件-&gt;【点击】OK按钮 -&gt; 【重启】IDEA。","tags":[{"name":"springboot","slug":"springboot","permalink":"http://tsdking.github.io/tags/springboot/"}]},{"title":"Android反编译的简单总结","date":"2018-04-19T17:34:59.000Z","path":"2018/04/20/apkuncode/","text":"Android反编译的简单总结准备 apktool.jar 安卓apk反编译神器,主要作用于资源文件,清单文件等,也可用于jar;解码\\构建 双向全能,用过的都说好. apktool.bat 一段脚本,结合apktool.jar使用 Java 7 (JRE 1.7)及以上,使用java -version查看 dex2jar 用于android的将classes.dex转换成jar的工具,可结合JD-GUI使用 JD-GUI 免安装,非商业用途的java反编译器,如可用于查看jar包中的代码 了解smali语法并且会使用 Android SDK, AAPT 安装 若已安装,可跳过 Windows 复制如下脚本,并另存为apktool.bat 12345@echo offif \"%PATH_BASE%\" == \"\" set PATH_BASE=%PATH%set PATH=%CD%;%PATH_BASE%;chcp 65001 2&gt;nul &gt;nuljava -jar -Duser.language=en -Dfile.encoding=UTF8 \"%~dp0\\apktool.jar\" %* 下载最新版的apktool 把下载好的jar重命名为apktool.jar 把上述两个文件apktool.bat &amp; apktool.jar放到同一个文件夹下,如C:\\windows (可选)如果你愿意,可以把第4步的路径添加到系统的环境变量里(&amp;PATH) 打开cmd 输入apktool 检查是否输入帮助信息,是否安装成功 Linux 复制如下脚本,并另存为apktool 12345@echo offif \"%PATH_BASE%\" == \"\" set PATH_BASE=%PATH%set PATH=%CD%;%PATH_BASE%;chcp 65001 2&gt;nul &gt;nuljava -jar -Duser.language=en -Dfile.encoding=UTF8 \"%~dp0\\apktool.jar\" %* 下载最新版的apktool 把下载好的jar重命名为apktool.jar 把上述两个文件apktool &amp; apktool.jar放到同一个文件夹下,如/usr/local/bin 确保上述文件有可执行权限chmod +x Terminal运行apktool Mac OS X 复制如下脚本,并另存为apktool 12345@echo offif \"%PATH_BASE%\" == \"\" set PATH_BASE=%PATH%set PATH=%CD%;%PATH_BASE%;chcp 65001 2&gt;nul &gt;nuljava -jar -Duser.language=en -Dfile.encoding=UTF8 \"%~dp0\\apktool.jar\" %* 下载最新版的apktool 把下载好的jar重命名为apktool.jar 把上述两个文件apktool &amp; apktool.jar放到同一个文件夹下,如/usr/local/bin 确保上述文件有可执行权限chmod +x Terminal运行apktool 注意 apktool脚本并不是必须的,它只是帮你省去了`java -jar apktool.jar`这样重复的指令 用法Apktool首先我们要了解一下apk的结构,apk只是一个包含资源以及java代码的zip文件,可使用任何解压软件直接解压(如7zip),解压后可以得到诸如 classes.dex and resources.arsc这样的文件 12345678$ unzip testapp.apkArchive: testapp.apk inflating: AndroidManifest.xml inflating: classes.dex extracting: res/drawable-hdpi/ic_launcher.png inflating: res/xml/literals.xml inflating: res/xml/references.xml extracting: resources.arsc 然而 这个时候只是解压了apk,如果你打开AndroidManifest.xml将会看到下面这些神秘字符 亦或是这些神秘字符,反正看不懂就对了 现在apktool排上用场了 解码123456789101112$ apktool.bat d -f girl.apk -o zshI: Using Apktool 2.3.2 on girl.apkI: Loading resource table...I: Decoding AndroidManifest.xml with resources...I: Loading resource table from file: C:\\Users\\Administrator\\AppData\\Local\\apktool\\framework\\1.apkI: Regular manifest package...I: Decoding file-resources...I: Decoding values */* XMLs...I: Baksmaling classes.dex...I: Copying assets and libs...I: Copying unknown files...I: Copying original files... 解释一下上述指令中各参数的定义 girl.apk为要解码的安装包,名字随便起的 1d,decode 解码 1-f, --force 若目标输出文件夹已经存在,则先强制删除 1-o, --output &lt;FILE&gt; 指定目标输出文件夹,若没有则自动创建 其他可选项 1-api, --api-level &lt;API&gt; 要生成的smali文件的数字api级别（默认为targetSdkVersion） 1-b, --no-debug-info 防止baksmali写出调试信息（.local，.param，.line等）,比较不同版本apk的smali文件时使用,行号和调试将在各个版本之间改变，这可能会使阅读DIFF报告变得很痛苦。 1--keep-broken-res 当尝试反编译一个非当前标准结构的apk时,会出现类似”Invalid Config Flags Detected. Dropping Resources…”的错误信息,这可能是用于使用了未知新版本的AndroidSDK构建或非已知标准结构的apk,使用上述命名可以允许错误继续decode,但是产生的错误信息需要你手动修复 1-m, --match-original 解码时将尽可能保持与原始文件一致,但是这样做可能会影响到重新构建rebuild 1--no-assets 解码时如果遇到未知的asset资产文件直接跳过 1-p, --frame-path &lt;DIR&gt; 指定本地framework文件的路径,这个后面会讲到,该文件解码时会用到,不指定时,apktool会到默认的路径C:\\Users\\Administrator\\AppData\\Local\\apktool\\framework\\中查找,找不到就下载 1-r, --no-res 如果只是编辑Java (smali) 文件,则推荐使用,因为它使 resources.arsc保持不变,官方说法是without any decode.,这样解码与重构都会更快 1-s, --no-src 和上述命名类似,如果只是编辑资源文件,则推荐使用,因为它使 *.dex保持不变,同样官方说法是without any decode.,这样解码与重构都会更快 1-t, --frame-tag &lt;TAG&gt; 解码时,使用指定tag的framework文件,这个用的很少,知道就行了 重新构建1234567$ apktool.bat b girl -o newGirl.apkI: Using Apktool 2.3.2I: Checking whether sources has changed...I: Checking whether resources has changed...I: Building apk file...I: Copying unknown files/dir...I: Built apk... 注意若不指定-o newGirl.apk,则默认的输出路径为girl/build/dist 构建时可用的选项 1-c, --copy-original 官方表示即将弃用该选项,它表示使用原apk的签名等信息 Copies original AndroidManifest.xml and META-INFfolder into built apk. 1-d, --debug 自动在清单文件中添加debuggable=&quot;true&quot; ,良心操作 1-f, --force-all 在构建过程中覆盖现有文件，重新组合resources.arsc文件和dex文件（s） 1--use-aapt2 框架文件的加载位置 补充Android应用程序一般会依赖或使用系统framework层的的代码和资源,这里简称为’框架资源’,Apktool工作时也是需要这些框架资源的; 使用最新版的apktool时,它内部已经包含了当前正式发布的最新的AOSP 框架层数据,所以会较少遇到问题,但是由于android系统毫无节制的开放性,国内各厂商把源码改的乱七八糟,这其中当然包括framework层;当尝试decode这些定制rom中的应用时,则需要先安装各厂商的framework files 下面引入一个官方的例子 如果你想要解码 HtcContacts.apk(HTC系统的通讯录应用),可能会得到下面的错误 1234567$ apktool d HtcContacts.apkI: Loading resource table...I: Decoding resources...I: Loading resource table from file: 1.apkW: Could not decode attr value, using undecoded value instead: ns=android, name=drawableW: Could not decode attr value, using undecoded value instead: ns=android, name=iconCan&apos;t find framework resources for package of id: 2. You must install proper framework files, see project website for more info. 所以在解码之前,需要先从HTC设备中pull出框架资源 com.htc.resources.apk并且安装它;123456789$ apktool if com.htc.resources.apkI: Framework installed to: 2.apk$ apktool d HtcContacts.apk I: Loading resource table...I: Decoding resources...I: Loading resource table from file: /home/brutall/apktool/framework/1.apkI: Loading resource table from file: /home/brutall/apktool/framework/2.apkI: Copying assets and libs... 从设备中找到框架资源文件(这一步只能靠猜了): 可能的文件路径 /system/framework /data/system-framework /system/app /system/priv-app 可能的文件名 resources res framework apktool在使用这些文件时会自动缓存到默认目录下 unix - $HOME/.local/share/apktool windows - %UserProfile%\\AppData\\Local\\apktool mac - $HOME/Library/apktool 如:我的是在C:\\Users\\Administrator\\AppData\\Local\\apktool\\framework 这个选项或许有用 1apktool empty-framework-dir Dex2jar方式一: 修改apk扩展名为zip 解压并拷贝classes.dex文件到dex2jar目录 右键在dex2jar目录中打开cmd,保证cmd的工作路径是在当前目录,否则就cd进来 cmd中运行d2j-dex2jar.bat classes.dex 自动生成classes-dex2jar.jar 文件,接下来就可以用JD-GUI打开了查看源码 方式二: 拷贝test.apk到dex2jar安装目录 打开cmd,直接运行d2j-dex2jar.bat test.apk 自动生成test-dex2jar.jar 文件,接下来就可以用JD-GUI打开了查看源码 JD-GUI 用法比较简单,直接把上一步生成的jar包拖到jd-gui.exe打开即可 Google开源的神器ClassyShark 可以可靠地浏览任何Android可执行文件并显示重要信息，例如类接口和成员，dex数量和依赖关系。 ClassyShark支持多种格式，包括库（.dex，.aar，.so），可执行文件（.apk，.jar，.class）和所有Android二进制XML：AndroidManifest，资源，布局等。 直接查看apk结构资源,甚至源码 在一定程度上: ClassyShark = Apktool+dex2jar+JD-DUI 用法: 下载 最新的JAR ,执行 java -jar ClassyShark.jar","tags":[{"name":"android","slug":"android","permalink":"http://tsdking.github.io/tags/android/"}]},{"title":"定时执行周期任务之AlarmManager，了解一下","date":"2018-04-18T04:28:14.000Z","path":"2018/04/18/alarmmanager/","text":"报菜名 ​ AlarmManager可用于计划未来的单次或重复的操作，甚至在应用程序没有运行时也可以执行任务，它通过PendingIntent触发执行各种系统组件，如BroadcastReceiver，Activity或Service等。 ​ 或者说AlarmManager比较适用于应用程序没有运行但仍然需要执行某些操作的场景。如果程序运行时需要执行简单的定时操作，使用Handler的postAtTime()和postDelay()就可以了。 在设备重启后，提醒自动失效，需要手动计划之前注册的提醒 注意事项唤醒类型 ELAPSED_REALTIME ELAPSED_REALTIME_WAKEUP RTC RTC_WAKEUP 根据设备上次启动以来的时间值（毫秒）触发提醒 根据经过的时间触发提醒，如果设备处于休眠状态，将被激活 根据UTC时间触发警告 根据UTC时间触发警告，如果设备处于休眠状态，将被激活 注意，如果使用ELAPSED_REALTIME_WAKEUP或RTC_WAKEUP这种唤醒类型的提醒，系统虽然会被唤醒但是不会保持唤醒状态，在执行唤醒事件的后台工作时，需要通过PowerManager获得WakeLock，否则系统会重新将设备转入休眠状态，你要本要执行的操作也会被停止。 ###PendingIntent PendingIntent有很多构造方法，但是必须要保证它能正确的指向要触发的应用程序组件。 上菜AlarmReceiver12345678910111213141516171819public class AlarmReceiver extends BroadcastReceiver &#123; private IntentFilter mIntentFilter; public static final String ACTION_ALARM = \"ACTION_ALARM\"; public AlarmReceiver() &#123; mIntentFilter = new IntentFilter(); mIntentFilter.addAction(ACTION_ALARM); &#125; @Override public void onReceive(Context context, Intent intent) &#123; if (mIntentFilter.matchAction(intent.getAction())) &#123; Calendar now = Calendar.getInstance(); Toast.makeText(context, \"Msg：\" + SimpleDateFormat.getTimeInstance().format(now.getTime()), Toast.LENGTH_SHORT).show(); &#125; &#125;&#125; 注意注册：1&lt;receiver android:name=\".AlarmReceiver\"/&gt; AlarmActivity 1234567891011121314151617181920212223242526272829public class AlarmActivity extends AppCompatActivity &#123; private AlarmManager mAlarmManager; private PendingIntent mPendingIntent; private Intent mIntent; private long mInterval = 5000; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_alarm); mAlarmManager = (AlarmManager) getSystemService(Context.ALARM_SERVICE); mIntent = new Intent(this,AlarmReceiver.class); mIntent.setAction(AlarmReceiver.ACTION_ALARM); mPendingIntent = PendingIntent.getBroadcast(this, 0, mIntent, 0); &#125; public void start(View view) &#123; mAlarmManager.setRepeating( AlarmManager.ELAPSED_REALTIME, SystemClock.elapsedRealtime() + mInterval, mInterval, mPendingIntent); &#125; public void cancle(View view) &#123; mAlarmManager.cancel(mPendingIntent); &#125;&#125; 示例2 每天上午9点执行任务12345678910111213141516171819202122232425public void start2(View view) &#123; long oneDay=24*3600*100; long firstTime; //创建一个日历，并设置提醒的时间为09:00 Calendar startTime = Calendar.getInstance(); startTime.set(Calendar.HOUR_OF_DAY,9); startTime.set(Calendar.MINUTE,0); startTime.set(Calendar.SECOND,0); Calendar now=Calendar.getInstance(); if (now.before(startTime))&#123; //现在还没到上午9点，从今天算起 firstTime=startTime.getTimeInMillis(); &#125;else&#123; //从明天上午9点算起 startTime.add(Calendar.DATE,1); firstTime=startTime.getTimeInMillis(); &#125; //设置提醒 mAlarmManager.setRepeating( AlarmManager.RTC_WAKEUP, firstTime, oneDay, mPendingIntent); &#125; 最后​ 十九岁那年的分水岭，Android4.4（19）开始所有的提醒都是不准确的，这意味着讲通过一个小窗口触发它们，连同这个新行为还一起添加了API方法setExat(),通过这个方法我们可以声明下面的提醒不能放入不准确的窗口。 ​","tags":[{"name":"android","slug":"android","permalink":"http://tsdking.github.io/tags/android/"}]},{"title":"定时执行周期任务之JobScheduler,了解一下","date":"2018-04-17T09:34:59.000Z","path":"2018/04/17/jobscheduler/","text":"JobScheduler是Android5.0及以后的版本由系统提供的用于解决高效处理计划后台工作的系统服务即使应用程序进程当前未运行,计划的任务也会运行,框架自动处理为计划作业获得唤醒锁的工作,从而甚至在设备空闲时,工作也会继续进行. 应用场景- 后台周期性任务 - 非及时性工作如定期数据库数据更新 - 设备充电时需要执行的工作,一般是不需要经常执行但是比较耗时耗电的操作如上传一些资源,网络拉取一些统计数据之类的 - 设备空闲时(未激活,休眠时)需要执行的工作 - 特定网络状态时才需要执行的工作 适用版本1Android 5.0以上即SDK&gt;=21 优点1. 避免频繁的唤醒硬件模块，造成不必要的电量消耗 2. 避免在不合适的时间(例如低电量情况下、弱网络或者移动网络情况下的)执行过多的任务消耗电量 3. Android Framework层会尝试尽可能的**成批执行**操作,从而最大限度减少对设备电池和网络使用率的影响 缺点非严格的计时,即计时的默认操作可能是不准确的 看代码WorkJobService123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@TargetApi(Build.VERSION_CODES.LOLLIPOP)public class WorkJobService extends JobService &#123; private static final int MSG_JOB = 1; private Handler mJobProcessor = new Handler(new Handler.Callback() &#123; @Override public boolean handleMessage(Message msg) &#123; if(msg.what==MSG_JOB)&#123; JobParameters params = (JobParameters) msg.obj; /** * 完成异步工作之后 必须触发jobFinished以使下一个计划任务运行 */ doSomething(); jobFinished(params, false); &#125; return true; &#125; &#125;); private void doSomething() &#123; Toast.makeText(this, \"time:\" + System.currentTimeMillis(), Toast.LENGTH_SHORT).show(); &#125; @Override public boolean onStartJob(JobParameters params) &#123; mJobProcessor.sendMessageDelayed( Message.obtain(mJobProcessor, MSG_JOB, params), 5000); /** * 1.如果此处异步完成作业,false; * 2.如果需要执行更多后台工作,true; * 对于第二种情况必须调用jobFinished()以通知系统作业完成 */ return true; &#125; @Override public boolean onStopJob(JobParameters params) &#123; //停止作业时,必须取消挂起的作业 mJobProcessor.removeMessages(MSG_JOB); /** * true计划作业 * false删除作业 */ return false; &#125;&#125; 注意:不要忘记在清单文件中注册,JobService本身继承Service,和普通的service区别是需要加上这个权限 android:permission=&quot;android.permission.BIND_JOB_SERVICE&quot;,否则在执行计划任务时会产生异常,我们需要将此服务暴露给framework,因此Android要求通过BIND_JOB_SERVICE权限保护该服务,只有framework可以拥有该权限,它保护我们的服务不被其他应用程序访问,123456789101112 &lt;application android:allowBackup=\"true\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:supportsRtl=\"true\" android:testOnly=\"false\" android:theme=\"@style/AppTheme\"&gt; ...... &lt;service android:name=\".WorkJobService\" android:permission=\"android.permission.BIND_JOB_SERVICE\"/&gt; ......&lt;/application&gt; JobSchedulerActivity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class JobSchedulerActivity extends AppCompatActivity &#123; JobScheduler jobScheduler; int interval = 5000; public static final int JOB_ID = 1; private JobInfo mJobInfo; @TargetApi(Build.VERSION_CODES.LOLLIPOP) @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_job_scheduler); jobScheduler = (JobScheduler) getSystemService(Context.JOB_SCHEDULER_SERVICE); mJobInfo = new JobInfo.Builder( JOB_ID, new ComponentName(getPackageName(), WorkJobService.class.getName()) ) /** * 表示应在给定时间间隔内定期运行作业,直到其被明确取消 */ .setPeriodic(interval) /** * 描述作业运行必备的网络条件 * NETWORK_TYPE_NONE = 0 默认值,表示作业不需要网络访问 * NETWORK_TYPE_ANY = 1 需要网络连接 * NETWORK_TYPE_UNMETERED = 2 必须是wifi网络状态,否则不会触发作业 */ .setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY) /** * 作业运行,必须时在设备充电状态 * 适合较少执行,但是比较耗电的任务 */ .setRequiresCharging(true) /** * 作业运行,必须时在设备未激活或睡眠状态 * 适合较少执行,但是比较耗电的任务 */ .setRequiresDeviceIdle(true) /** * 设置设备重启时,如何启动计划作业 * true 由framework自动启动计划作业 * false 由应用手动启动计划作业(默认) */ .setPersisted(false) /** * 设置对于失败的作业如何何时重新计划使其再次运行 * 如:在资源(网络访问等)临时不可用时尽可能减少不必要的重试次数 */ .setBackoffCriteria(DEFAULT_INITIAL_BACKOFF_MILLIS, BACKOFF_POLICY_EXPONENTIAL) .build(); &#125; @TargetApi(Build.VERSION_CODES.LOLLIPOP) public void start(View view) &#123; /** * 多次执行同一个任务返回同一个任务id,不会重复执行任务 */ int result = jobScheduler.schedule(mJobInfo); if (result &lt;= 0) &#123; Toast.makeText(this, \"失败\", Toast.LENGTH_SHORT).show(); &#125;else&#123; Toast.makeText(this, \"成功\", Toast.LENGTH_SHORT).show(); &#125; &#125; @TargetApi(Build.VERSION_CODES.LOLLIPOP) public void stop(View view) &#123; /** * 任务id必须匹配传递给JobInfo的id,需要保存该id */ jobScheduler.cancel(JOB_ID); &#125;&#125;","tags":[{"name":"android","slug":"android","permalink":"http://tsdking.github.io/tags/android/"}]},{"title":"最快最简单的排序算法","date":"2018-04-16T15:31:58.000Z","path":"2018/04/16/sort-algorithm-1/","text":"桶排序的基本思想是将一个数据表分割成许多buckets，然后每个bucket各自排序，或用不同的排序算法，或者递归的使用bucket sort算法。也是典型的divide-and-conquer分而治之的策略。它是一个分布式的排序，介于MSD基数排序和LSD基数排序之间。 基本流程 建立一堆buckets； 遍历原始数组，并将数据放入到各自的buckets当中； 对非空的buckets进行排序； 按照顺序遍历这些buckets并放回到原始数组中即可构成排序后的数组。 12345678910111213141516171819202122232425262728293031public static void main(String[] args) &#123; /** * 定义一个length=11的int数组book用来记录 * 并舒适化默认值都为0 */ int[] book=new int[11]; int length1 = book.length; for (int i = 0; i &lt; 11; i++) &#123; book[i]=0; &#125; /** * 定义一个任意length的数组source，但是保证数组中每个元素在[0,10]内 */ int[] source=&#123;0,8,3,3,5,2,9&#125;; int length = source.length; for (int i = 0; i &lt; length; i++) &#123; /** * source中的元素每出现一次 * book中对应下标的值就加1 */ book[source[i]]++; &#125; for (int i = 10; i &gt;= 0; i--) &#123; /** * 序号出现几次就打印几次 */ for (int j = 1; j &lt;=book[i] ; j++) &#123; System.out.print(i+\" \"); &#125; &#125; &#125; 简单解释上述代码是桶排序算法简单的java实现，形象地描述就是如果我们要对0~10之间的数字排序，那么我们就准备11个桶（0~10共11个数），每出现一个数，就在对应编号的桶中放一个小旗子，最后只要数一数每个桶中有几个小旗子就行了。 优点每个桶的作用实际就是标记每个数出现的次数。该算法的时间复杂度是O（m+n+m+n）即O（2*（m+n）），忽略较小的常数，最终桶排序的时间复杂度为O（M+N），这是一个很快的排序算法（时间复杂度通常用大写字母表示）； 缺点特费空间，这是典型的空间换时间，还有如果要对一些小数排序，怎么办？","tags":[{"name":"算法","slug":"算法","permalink":"http://tsdking.github.io/tags/算法/"}]},{"title":"Hexo博客搭建笔记","date":"2018-04-14T08:34:09.740Z","path":"2018/04/14/hexo-blog-note/","text":"一、安装基础环境 Node.js Git具体安装过程自行搜索，通过以下两条命令验证是否安装成功，否则不能执行第二步；12node --versiongit --version 二、安装hexoHexo官网 1npm install hexo-cli -g 三、初始化项目 使用如下命令初始化项目1hexo init blog 命令中blog可随意命名，有意义即可，相当于项目的根目录，以后所有的操作都在该目录下，该命令在哪执行就在哪创建项目；当然，也可以先创建项目文件夹，cd到项目文件夹后再执行init命令。命令执行后，框架会自动下载相关资源，并完成初始化该过程的长短取决于你的网速 生成各目录的作用 node_modules：各种依赖包 public：存放生成的静态页面 scaffolds：命令生成文章等的模板 source：用命令创建的各种文章md文件 themes：存放各种主题 _config.yml：整个博客的配置 db.json：source解析所得到的 package.json：项目所需模块项目的配置信息 2.进入项目目录,安装框架依赖的模块 1npm install 该命令会安装 ./node_modules目录下的安装包 至此，整个项目初始化完成，可以执行以下命令欣赏一下了 1hexo server 该命令主要用来启动本地服务器，预览项目 四、安装主题（可选）这里简单推荐几个： hexo-theme-indigo hexo-theme-next hexo-theme-yilia hexo-theme-material hexo-theme-icarus 具体配置请查看各主题wiki文档，可能会用到的几个命令 123hexo cleanhexo ghexo server 五,发布到GitHub Pages 以.github.io为名创建一个新仓库，具体操作看官方文档 简单配置一下_config.yml文件12345deploy: type: git repo: git@github.com:tsdking/tsdking.github.io.git branch: master message: &apos;站点更新:&#123;&#123;now(&quot;YYYY-MM-DD HH/mm/ss&quot;)&#125;&#125;&apos; 注意repo换成自己上一步新建仓库的地址 六、发布1hexo d -g 注意：需要先安装hexo-deployer-git1npm install hexo-deployer-get --save","tags":[]},{"title":"Hello World","date":"2017-11-28T07:02:25.505Z","path":"2017/11/28/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]